# Polkadot Substrate Haskell API

## Project Description

We are building a Haskell API for Substrate and Polkadot. It will enable developers to read chain information, state, and block details, as well as sign and publish transactions via Haskell. This will also include a subscription API to connect to substrate nodes’ websocket endpoints and receive real-time data updates. A core feature of the API will be code generation tools for API metadata, providing type-safe interaction with any substrate node.
Haskell is a statically typed, purely functional programming language that is great for building type-safe, performant programs quickly and reliably. Haskell’s active developer community and outright advantages as a language make it a valuable addition to the Polkadot ecosystem.

By combining Template Haskell, a DSL for auto-generating Haskell code, with the API metadata, clients for any substrate API can be generated. Developers can easily interface with these APIs without burdensome boilerplate.

We’re interested in this because we’re designing a parachain for non-fungible token metadata. We aim to solve the problem of metadata stored in central locations, such as a company’s own IPFS node, or private servers. Our parachain gives owners of NFTs the ability to also take ownership over the metadata, rather than relying on a trusted third party to host it.

## Team members

- Charles Crain
- John Crain
- Jonathan Perkins

## Team Website

- https://pixura.io

## Legal Structure

Information in Google form.

## Team's experience

The Pixura team has been building in the Ethereum and distributed systems space for several years. In 2018, they launched the NFT exchange [SuperRare.co](https://superrare.co), one of the most active collectibles projects on Ethereum. They also launched [platform.pixura.io](https://platform.pixura.io), a generalized tool to create P2P digital item marketplaces on Ethereum.
The Pixura team has deep knowledge of distributed/decentralized applications, Haskell, Solidity, IPFS, and Ethereum, including open source contributions to [hs-web3](https://hs-web3.readthedocs.io/en/latest/) and the [Haskell Cosmos SDK](https://github.com/f-o-a-m/hs-abci). Short background on individual team members is below.

Charles Crain will be the principal engineer leading development . He has worked in the Ethereum space for 4+ years, and has a diverse background in distributed systems. He worked extensively on a Haskell Ethereum node implementation as well work on JP Morgan’s Quorum. Charles designed and built the Ethereum indexer which feeds the data pipeline powering SuperRare and Pixura Platform. He is a frequent open source contributor, including work earlier this year on the Haskell implementation of Cosmos’ SDK.

John Crain will be an engineer working on the project, focusing on design and architecture, and will be the main point of contact for the grant application. John has been in the blockchain space since 2015, when he joined NYC-based ConsenSys as a product engineer, and later was a founding member of enterprise Ethereum platform BlockApps.

Jonathan Perkins will be an engineer on the project and will be in charge of project management and coordination. Jonathan is a full stack engineer with a background in product management. At Pixura, Jonathan has served as head of product, leading UI layer engineering and product strategy. Prior to co-founding Pixura, he worked as a software engineer at Reaktor, a global technology consultancy.

## Team Code Repos

- https://github.com/Pixura/pixura-contracts\
- https://github.com/f-o-a-m/hs-abci
- https://github.com/charlescrain/hs-web3/tree/raw-event-listener
- https://github.com/charlescrain/eth-pruner
- https://github.com/charlescrain/quorum

## Team LinkedIn Profiles

- https://www.linkedin.com/in/charles-crain-20a28871/
- https://www.linkedin.com/in/johnacrain/
- https://www.linkedin.com/in/jonathan-perkins-08057715/

## Development Roadmap

### Milestone 1

#### Duration: 4 weeks

#### Deliverables:

- Live repo for Haskell Substrate/Polkadot API with a readme that describes how to run, test & contribute
- Docker environment with working local testnet
- CI for building & testing
- Haskell implementation of the SCALE codec (https://github.com/paritytech/parity-scale-codec)
- Type definitions for substrate types and codecs

#### Payout: \$10,000 USD

### Milestone 2

#### Duration: 4 weeks

#### Deliverables:

- Basic Substrate RPC implementation
- Tests for RPC implementation
- Metadata parsing library
- Tests for metadata parsing library
- Template Haskell for generating clients based off of API metadata
- Tests for template Haskell to create expected declarations

#### Payout: \$10,000 USD

### Milestone 3

#### Duration: 4 weeks

#### Deliverables:

- Polkadot client generated by metadata
- Tests for polkadot client
- CLI tool for generating clients based off of node URL
- Publish to Hackage & Stackage (Haskell open source package management & documentation hubs)
- Tutorial w/ examples & diagrams

#### Payout: \$10,000 USD

## Additional Information

### Specification Details

### account

_(Optional) Methods that retrieve account-specific information_

insertKey(keyType: `Text`, suri: `Text`, publicKey: `Bytes`): `Bytes`

- jsonrpc: author_insertKey
- interface: api.rpc.author.insertKey
- summary: Insert a key into the keystore.

pendingExtrinsics(): `Vec<Extrinsic>`

- jsonrpc: author_pendingExtrinsics
- interface: api.rpc.author.pendingExtrinsics
- summary: Returns all pending extrinsics, potentially grouped by sender

removeExtrinsic(bytesOrHash: Vec`<ExtrinsicOrHash>`): Vec`<Hash>`

- jsonrpc: author_removeExtrinsic
- interface: api.rpc.author.removeExtrinsic
- summary: Remove given extrinsic from the pool and temporarily ban it to prevent reimporting

rotateKeys(): `Bytes`

- jsonrpc: author_rotateKeys
- interface: api.rpc.author.rotateKeys
- summary: Generate new session keys and returns the corresponding public keys

submitAndWatchExtrinsic(extrinsic: `Extrinsic`): `ExtrinsicStatus`

submitExtrinsic(extrinsic: `Extrinsic`): `Hash`

- jsonrpc: author_submitExtrinsic
- interface: api.rpc.author.submitExtrinsic
- summary: Submit a fully formatted extrinsic for block inclusion

### chain

_Retrieval of chain data_

getBlock(hash?: `Hash`): `SignedBlock`

- jsonrpc: chain_getBlock
- interface: api.rpc.chain.getBlock
- summary: Get header and body of a relay chain block

getBlockHash(blockNumber?: `BlockNumber`): `Hash`

- jsonrpc: chain_getBlockHash
- interface: api.rpc.chain.getBlockHash
- summary: Get the block hash for a specific block

getFinalizedHead(): `Hash`

- jsonrpc: chain_getFinalizedHead
- interface: api.rpc.chain.getFinalizedHead
- summary: Get hash of the last finalized block in the canon chain

getHeader(hash?: `Hash`): `Header`

- jsonrpc: chain_getHeader
- interface: api.rpc.chain.getHeader
- summary: Retrieves the header for a specific block

subscribeFinalizedHeads(): `Header`

- jsonrpc: chain_subscribeFinalizedHeads
- interface: api.rpc.chain.subscribeFinalizedHeads
- summary: Retrieves the best finalized header via subscription

subscribeNewHeads(): `Header`

- jsonrpc: chain_subscribeNewHeads
- interface: api.rpc.chain.subscribeNewHeads
- summary: Retrieves the best header via subscription

### contracts

_(Optional) Methods that perform actions on contracts_

call(callRequest: `ContractCallRequest`, at?: `Hash`): `ContractExecResult`

- jsonrpc: contracts_call
- interface: api.rpc.contracts.call
- summary: Executes a call to a contract

### rpc

_Retrieves information about the RPC endpoints_

methods(): `RpcMethods`

- jsonrpc: rpc_methods
- interface: api.rpc.rpc.methods
- summary: Retrieves the list of RPC methods that are exposed by the node

### state

_Query of state_

call(method: `Text`, data: `Bytes`, block?: `Hash`): `Bytes`

- jsonrpc: state_call
- interface: api.rpc.state.call
- summary: Perform a call to a builtin on the chain

getChildKeys(childStorageKey: `StorageKey`, key: `StorageKey`, block?: `Hash`): `Vec<StorageKey>`

- jsonrpc: state_getChildKeys
- interface: api.rpc.state.getChildKeys
- summary: Retrieves the keys with prefix of a specific child storage

getChildStorage(childStorageKey: `StorageKey`, key: `StorageKey`, block?: `Hash`): `StorageData`

- jsonrpc: state_getChildStorage
- interface: api.rpc.state.getChildStorage
- summary: Retrieves the child storage for a key

getChildStorageHash(childStorageKey: `StorageKey`, key: `StorageKey`, block?: `Hash`): `Hash`

- jsonrpc: state_getChildStorageHash
- interface: api.rpc.state.getChildStorageHash
- summary: Retrieves the child storage hash

getChildStorageSize(childStorageKey: `StorageKey`, key: `StorageKey`, block?: `Hash`): `u64`

- jsonrpc: state_getChildStorageSize
- interface: api.rpc.state.getChildStorageSize
- summary: Retrieves the child storage size

getKeys(key: `StorageKey`, block?: `Hash`): `Vec<StorageKey>`

- jsonrpc: state_getKeys
- interface: api.rpc.state.getKeys
- summary: Retrieves the keys with a certain prefix

getMetadata(block?: `Hash`): `Metadata`

- jsonrpc: state_getMetadata
- interface: api.rpc.state.getMetadata
- summary: Returns the runtime metadata

getRuntimeVersion(hash?: `Hash`): `RuntimeVersion`

- jsonrpc: state_getRuntimeVersion
- interface: api.rpc.state.getRuntimeVersion
- summary: Get the runtime version

getStorage(key: `StorageKey`, block?: `Hash`): `StorageData`

- jsonrpc: state_getStorage
- interface: api.rpc.state.getStorage
- summary: Retrieves the storage for a key

getStorageHash(key: `StorageKey`, block?: `Hash`): `Hash`

- jsonrpc: state_getStorageHash
- interface: api.rpc.state.getStorageHash
- summary: Retrieves the storage hash

getStorageSize(key: `StorageKey`, block?: `Hash`): `u64`

- jsonrpc: state_getStorageSize
- interface: api.rpc.state.getStorageSize
- summary: Retrieves the storage size

queryStorage(keys: `Vec<StorageKey>`, startBlock: `Hash`, block?: `Hash`): `Vec<StorageChangeSet>`

- jsonrpc: state_queryStorage
- interface: api.rpc.state.queryStorage
- summary: Query historical storage entries (by key) starting from a start block

subscribeRuntimeVersion(): `RuntimeVersion`

- jsonrpc: state_subscribeRuntimeVersion
- interface: api.rpc.state.subscribeRuntimeVersion
- summary: Retrieves the runtime version via subscription

subscribeStorage(keys: `Vec<StorageKey>`): `StorageChangeSet`

- jsonrpc: state_subscribeStorage
- interface: api.rpc.state.subscribeStorage
- summary: Subscribes to storage changes for the provided keys

### system

_Calls to retrieve system info_

chain(): `Text`

- jsonrpc: system_chain
- interface: api.rpc.system.chain
- summary: Retrieves the chain

health(): `Health`

- jsonrpc: system_health
- interface: api.rpc.system.health
- summary: Return health status of the node

name(): `Text`

- jsonrpc: system_name
- interface: api.rpc.system.name
- summary: Retrieves the node name

networkState(): `NetworkState`

- jsonrpc: system_networkState
- interface: api.rpc.system.networkState
- summary: Returns current state of the network

peers(): `Vec<PeerInfo>`

- jsonrpc: system_peers
- interface: api.rpc.system.peers
- summary: Returns the currently connected peers

properties(): `ChainProperties`

- jsonrpc: system_properties
- interface: api.rpc.system.properties
- summary: Get a custom set of properties as a JSON object, defined in the chain spec

version(): `Text`

- jsonrpc: system_version
- interface: api.rpc.system.version
- summary: Retrieves the version of the node
